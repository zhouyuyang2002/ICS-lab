Phase 1:

传到 string_not_equal 里的参数是 %rsi(<_IO_stdin_used+0x200>) 和 %rdi(传入的参数)，因而大致意思就是输入相同的字符串即可。

利用 Hexeditor 找到，输入字符串为 Every day I wonder how I can make you happier.

Phase 2:

读入了 6 个数字，分别存储在 (%rsp) 到 14(%rsp)。

由 0x151f 和 0x1525 处知道，输入第 1,2 个数字分别是 0,1

观察后侧的代码，有：%rax + 2 = %rcx + 1 = %rdx., 且 %rdx 循环范围为 2~5.

观察在 0x154e 处的代码，得到了炸弹不爆炸当且仅当 a[%rax] + a[%rcx] = a[%rdx]。因此答案为 0 1 1 2 3 5

Phase 3:

0x1597 处调用了 scanf, 观察参数表格得到 "%d %d"，因而读入的是两个正整数，存在 (%rsp) 到 4(%rsp)。

0x15a8 处知道输入得第一个数字不能超过 7，之后会根据输入得第一个数字跳转到 0x1bd4 为基地址的一个跳转表。

进入跳转表最后会返回到 0x15d3 ~ 0x15f6 处的某个指令，求和后，将求和的值 %eax 和 4(%rsp) 比较。（注意这里有第一个输入的数 <= 5) 的限制。

因此在 0x1601 处设一个断点求出 %eax 的值后直接得到第二个数字。这里采用的是 4 0

Phase 4:

0x16b7 处调用了 scanf, 观察参数表格得到 "%d %d"，因而读入的是两个正整数，存在 (%rsp) 到 4(%rsp)。

由 0x16c1 处知道，输入的第一个数字是 6

然后代码会在 0x16cc~0x16e7 处打转，最后得到一个 %eax 和 4(%rsp) 比较。因此直接设置一个断点求出 %eax 的值后得到第二个数字。答案是 6 49

Phase 5:

0x1728 处调用了 string_length，知道输入的是一个字符串，长度为 6. 字符串指针在 %rbx 中

之后会跳转至 0x1740~0x175f 的循环中，%eax 的取值为 0~5。

观察循环体代码，他会先求出 %rbx[%eax] & 0xf 的值，之后求出 $0x31b0[s[%eax] & 0xf]，并将其存储到 %rsp[%eax] 中。

跳出循环后，%rsp 会和 $0x3031 的字符串比较，也就是和字符串 flyers 比较。

因此直接查 0x31b0 的对应字符表即可构造出 %rbx[%eax] & 0xf 的值，任意找合法字符串即可。这里选取的是 ionefg

Phase 6:

程序先读入了 6 个数，存储在 %rsp 到 $0x14(%rsp)。

第一个循环结构位于 0x17ce ~ 0x1805 中，分为两部分判断。0x17ee 之下部分会判断 %rsp[%ebp] 的值是否在 1~6 之间，0x17ee 之上部分会判断 %rsp[0]~%rsp[%ebp-1] 的值是否和 %rsp[%ebp] 的值相同。

第二个循环结构位于 0x180c ~ 0x1822 中，会将 %rsp[%ebp] 变为 7 - %rsp[%ebp]

第三个循环结构位于 0x1829 ~ 0x1853 中，会根据 206140 <node1> 处的一个链表，提取出第 %rsp[%rcx] 个元素的地址，存储在 0x20(%rsp,%rcx,8) 中

第四个循环结构位于 0x1862 ~ 0x1879 中，会按照 0x20(%rsp) 数组中的顺序重建链表。

第五个循环结构位于 0x1888 ~ 0x18a5 中，会按照 0x20(%rsp) 数组中的顺序检查元素是否已经有序，若无序触发炸弹。

因此在第三个循环运行完毕后检查内存处链表存储的值即可得到 7 - %rsp[%ebp] 的值，最后得到 %rsp[%ebp] 的值。得到答案为 2 3 6 4 1 5

Secret Phase

进入的入口在 phase_defuse 中。且观察后得到当且仅当在完成 Phase 6 后开始检查。检查共两轮 abracadabra 和 alohomora

abracadabra:

观察发现，他会在 0x13e0 处调用 scanf, 观察 0x301c 处的参数表，得到参数是 %d %d %d %d %d %d %s。

且由于调用前没有 read_line 知，输入字符串为某个 Phase 的输入。设置断点后，观察存储的内容确定的输入内容知为 Phase 2 的输入。

检查得知，最后 0x20(%rsp) 处存储的是最后输入的字符串，他会和 0x3038 的字符串比较。查阅源码后得到字符串为 NothingThatHasMeaning1sEasy...

alohomora

观察发现，他会在 0x1479 处调用 scanf, 观察 0x3028 处的参数表，得到参数是 %d %d %s。

且由于调用前没有 read_line 知，输入字符串为某个 Phase 的输入。设置断点后，观察存储的内容确定的输入内容知为 Phase 4 的输入。

之后会跳转到 0x14a3 ~ 0x14b1 处的循环中。其中 %rdx 为一个指向字符串某个位置的指针。观察循环发现它会将所有的字符的值加上 2

最后会和 0x3058 处的字符串比较，如果成功就触发隐藏关。

通过断点调试知，每一个字符都会被 +2，且比较的是全串。因此根据 0x3058 处的值，得到字符串为 ...EasyDoesntEnter1ntoGrownUpLife.


